# js实css属性 scroll-behavior
  技术点 
  - 点击目录对应的li元素拿到我们绑定的锚链接属性id的元素距离顶部的距离
  - 点击相应得元素利用运动函数(也就是我们这里得事件总线机制) 传入我们需要从当前位置移动到目标位置的移动距离 
   - 如何获取当前位置我们需要再事件总线中注册一个事件使我们出现滚动条的元素绑定在事件上 这个过程称之为发布订阅模式 
  - 使用this.$bus.$on('事件名称',(具有事件的dom元素 来拿到当前滚动条的位置 )=>{
    - 使用参数dom元素去获取他的scrollTop 也就是当前元素以滚动的距离 
    - 将其赋值给我们data中的一个数据
    - 因为再data中的数据会被vue监听他的变化以及实时跟新数据
  })
   - 得到当前点击元素距离顶部的位置 也就是 offsetTop非scrollTop
  # 运动函数的实现 
   - 我们需要再vue中使用一个事件总线也就是一个自定义的js模块 更好的去管理我们的事件以及去分发我们的数据
   - 前期我们需要在滚动元素的组件中去绑定元素 所以需要mixins去混合我们的mainScroll模块 还需要再全局中去定义我们的事件总线
   - 给当前传入进来的元素绑定一个滚动条事件 同时去methdos中注册一个对应得处理事件 也就是通过监听该元素得滚动条事件区分发我们得元素给我们需要监听滚动条事件得文件 给他们需压得数据 
   - 我们的运动函数需要接收一个参数作为我们的移动距离以及需要接受一个参数为我们每次需要移动的距离
   - 实现运动 我们这里用了 requestAnimationFrame api去完成我们的位置跟新 
   - 判断当前移动是否以及到达预期位置我们可以使用一个数据来记录当前位置 来实现我们运动开始的起始值 也需要再scroll事件处理函数中给其赋值(需要加锁来控制) 不然我们用户滚动页面但我们的处理模块中无法得知当前滚动条位置 也就会多移动一些距离
   - 判断当前运动是否结束需要我们去设置requestAnimationFrme执行的次数 最好使用计次 这个api会将我们的每一1000毫米分为60帧来执行 所以需要多少秒去完成事件就设置停止的次数 同时将锁解开 再函数进入是需要将锁加上 
   
